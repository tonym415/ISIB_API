<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/tony/public_html/assets/js/lib/additional-methods.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/app/appLib.contentMode.html">app/appLib.contentMode</a></li>
                                <li><a href="../classes/app/appLib.defaults.html">app/appLib.defaults</a></li>
                                <li><a href="../classes/app/appLib.steps.html">app/appLib.steps</a></li>
                                <li><a href="../classes/app/appLib.stepsOrientation.html">app/appLib.stepsOrientation</a></li>
                                <li><a href="../classes/app/appLib.transitionEffect.html">app/appLib.transitionEffect</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/app.html">app</a></li>
                                <li><a href="../modules/feedback.html">feedback</a></li>
                                <li><a href="../modules/game.html">game</a></li>
                                <li><a href="../modules/signup.html">signup</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/tony/public_html/assets/js/lib/additional-methods.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * jQuery Validation Plugin v1.14.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2015 Jörn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
		define( [&quot;jquery&quot;, &quot;validate&quot;], factory );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

(function() {

	function stripHtml(value) {
		// remove html tags and space chars
		return value.replace(/&lt;.[^&lt;&gt;]*?&gt;/g, &quot; &quot;).replace(/&amp;nbsp;|&amp;#160;/gi, &quot; &quot;)
		// remove punctuation
		.replace(/[.(),;:!?%#$&#x27;\&quot;_+=\/\-“”’]*/g, &quot;&quot;);
	}

	$.validator.addMethod(&quot;maxWords&quot;, function(value, element, params) {
		return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length &lt;= params;
	}, $.validator.format(&quot;Please enter {0} words or less.&quot;));

	$.validator.addMethod(&quot;minWords&quot;, function(value, element, params) {
		return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length &gt;= params;
	}, $.validator.format(&quot;Please enter at least {0} words.&quot;));

	$.validator.addMethod(&quot;rangeWords&quot;, function(value, element, params) {
		var valueStripped = stripHtml(value),
			regex = /\b\w+\b/g;
		return this.optional(element) || valueStripped.match(regex).length &gt;= params[0] &amp;&amp; valueStripped.match(regex).length &lt;= params[1];
	}, $.validator.format(&quot;Please enter between {0} and {1} words.&quot;));

}());

// Accept a value from a file input based on a required mimetype
$.validator.addMethod(&quot;accept&quot;, function(value, element, param) {
	// Split mime on commas in case we have multiple types we can accept
	var typeParam = typeof param === &quot;string&quot; ? param.replace(/\s/g, &quot;&quot;).replace(/,/g, &quot;|&quot;) : &quot;image/*&quot;,
	optionalValue = this.optional(element),
	i, file;

	// Element is optional
	if (optionalValue) {
		return optionalValue;
	}

	if ($(element).attr(&quot;type&quot;) === &quot;file&quot;) {
		// If we are using a wildcard, make it regex friendly
		typeParam = typeParam.replace(/\*/g, &quot;.*&quot;);

		// Check if the element has a FileList before checking each file
		if (element.files &amp;&amp; element.files.length) {
			for (i = 0; i &lt; element.files.length; i++) {
				file = element.files[i];

				// Grab the mimetype from the loaded file, verify it matches
				if (!file.type.match(new RegExp( &quot;\\.?(&quot; + typeParam + &quot;)$&quot;, &quot;i&quot;))) {
					return false;
				}
			}
		}
	}

	// Either return true because we&#x27;ve validated each file, or because the
	// browser does not support element.files and the FileList feature
	return true;
}, $.validator.format(&quot;Please enter a value with a valid mimetype.&quot;));

$.validator.addMethod(&quot;alphanumeric&quot;, function(value, element) {
	return this.optional(element) || /^\w+$/i.test(value);
}, &quot;Letters, numbers, and underscores only please&quot;);

/*
 * Dutch bank account numbers (not &#x27;giro&#x27; numbers) have 9 digits
 * and pass the &#x27;11 check&#x27;.
 * We accept the notation with spaces, as that is common.
 * acceptable: 123456789 or 12 34 56 789
 */
$.validator.addMethod(&quot;bankaccountNL&quot;, function(value, element) {
	if (this.optional(element)) {
		return true;
	}
	if (!(/^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test(value))) {
		return false;
	}
	// now &#x27;11 check&#x27;
	var account = value.replace(/ /g, &quot;&quot;), // remove spaces
		sum = 0,
		len = account.length,
		pos, factor, digit;
	for ( pos = 0; pos &lt; len; pos++ ) {
		factor = len - pos;
		digit = account.substring(pos, pos + 1);
		sum = sum + factor * digit;
	}
	return sum % 11 === 0;
}, &quot;Please specify a valid bank account number&quot;);

$.validator.addMethod(&quot;bankorgiroaccountNL&quot;, function(value, element) {
	return this.optional(element) ||
			($.validator.methods.bankaccountNL.call(this, value, element)) ||
			($.validator.methods.giroaccountNL.call(this, value, element));
}, &quot;Please specify a valid bank or giro account number&quot;);

/**
 * BIC is the business identifier code (ISO 9362). This BIC check is not a guarantee for authenticity.
 *
 * BIC pattern: BBBBCCLLbbb (8 or 11 characters long; bbb is optional)
 *
 * BIC definition in detail:
 * - First 4 characters - bank code (only letters)
 * - Next 2 characters - ISO 3166-1 alpha-2 country code (only letters)
 * - Next 2 characters - location code (letters and digits)
 *   a. shall not start with &#x27;0&#x27; or &#x27;1&#x27;
 *   b. second character must be a letter (&#x27;O&#x27; is not allowed) or one of the following digits (&#x27;0&#x27; for test (therefore not allowed), &#x27;1&#x27; for passive participant and &#x27;2&#x27; for active participant)
 * - Last 3 characters - branch code, optional (shall not start with &#x27;X&#x27; except in case of &#x27;XXX&#x27; for primary office) (letters and digits)
 */
$.validator.addMethod(&quot;bic&quot;, function(value, element) {
    return this.optional( element ) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-2])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test( value );
}, &quot;Please specify a valid BIC code&quot;);

/*
 * Código de identificación fiscal ( CIF ) is the tax identification code for Spanish legal entities
 * Further rules can be found in Spanish on http://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal
 */
$.validator.addMethod( &quot;cifES&quot;, function( value ) {
	&quot;use strict&quot;;

	var num = [],
		controlDigit, sum, i, count, tmp, secondDigit;

	value = value.toUpperCase();

	// Quick format test
	if ( !value.match( &quot;((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)&quot; ) ) {
		return false;
	}

	for ( i = 0; i &lt; 9; i++ ) {
		num[ i ] = parseInt( value.charAt( i ), 10 );
	}

	// Algorithm for checking CIF codes
	sum = num[ 2 ] + num[ 4 ] + num[ 6 ];
	for ( count = 1; count &lt; 8; count += 2 ) {
		tmp = ( 2 * num[ count ] ).toString();
		secondDigit = tmp.charAt( 1 );

		sum += parseInt( tmp.charAt( 0 ), 10 ) + ( secondDigit === &quot;&quot; ? 0 : parseInt( secondDigit, 10 ) );
	}

	/* The first (position 1) is a letter following the following criteria:
	 *	A. Corporations
	 *	B. LLCs
	 *	C. General partnerships
	 *	D. Companies limited partnerships
	 *	E. Communities of goods
	 *	F. Cooperative Societies
	 *	G. Associations
	 *	H. Communities of homeowners in horizontal property regime
	 *	J. Civil Societies
	 *	K. Old format
	 *	L. Old format
	 *	M. Old format
	 *	N. Nonresident entities
	 *	P. Local authorities
	 *	Q. Autonomous bodies, state or not, and the like, and congregations and religious institutions
	 *	R. Congregations and religious institutions (since 2008 ORDER EHA/451/2008)
	 *	S. Organs of State Administration and regions
	 *	V. Agrarian Transformation
	 *	W. Permanent establishments of non-resident in Spain
	 */
	if ( /^[ABCDEFGHJNPQRSUVW]{1}/.test( value ) ) {
		sum += &quot;&quot;;
		controlDigit = 10 - parseInt( sum.charAt( sum.length - 1 ), 10 );
		value += controlDigit;
		return ( num[ 8 ].toString() === String.fromCharCode( 64 + controlDigit ) || num[ 8 ].toString() === value.charAt( value.length - 1 ) );
	}

	return false;

}, &quot;Please specify a valid CIF number.&quot; );

/*
 * Brazillian CPF number (Cadastrado de Pessoas Físicas) is the equivalent of a Brazilian tax registration number.
 * CPF numbers have 11 digits in total: 9 numbers followed by 2 check numbers that are being used for validation.
 */
$.validator.addMethod(&quot;cpfBR&quot;, function(value) {
	// Removing special characters from value
	value = value.replace(/([~!@#$%^&amp;*()_+=&#x60;{}\[\]\-|\\:;&#x27;&lt;&gt;,.\/? ])+/g, &quot;&quot;);

	// Checking value to have 11 digits only
	if (value.length !== 11) {
		return false;
	}

	var sum = 0,
		firstCN, secondCN, checkResult, i;

	firstCN = parseInt(value.substring(9, 10), 10);
	secondCN = parseInt(value.substring(10, 11), 10);

	checkResult = function(sum, cn) {
		var result = (sum * 10) % 11;
		if ((result === 10) || (result === 11)) {result = 0;}
		return (result === cn);
	};

	// Checking for dump data
	if (value === &quot;&quot; ||
		value === &quot;00000000000&quot; ||
		value === &quot;11111111111&quot; ||
		value === &quot;22222222222&quot; ||
		value === &quot;33333333333&quot; ||
		value === &quot;44444444444&quot; ||
		value === &quot;55555555555&quot; ||
		value === &quot;66666666666&quot; ||
		value === &quot;77777777777&quot; ||
		value === &quot;88888888888&quot; ||
		value === &quot;99999999999&quot;
	) {
		return false;
	}

	// Step 1 - using first Check Number:
	for ( i = 1; i &lt;= 9; i++ ) {
		sum = sum + parseInt(value.substring(i - 1, i), 10) * (11 - i);
	}

	// If first Check Number (CN) is valid, move to Step 2 - using second Check Number:
	if ( checkResult(sum, firstCN) ) {
		sum = 0;
		for ( i = 1; i &lt;= 10; i++ ) {
			sum = sum + parseInt(value.substring(i - 1, i), 10) * (12 - i);
		}
		return checkResult(sum, secondCN);
	}
	return false;

}, &quot;Please specify a valid CPF number&quot;);

/* NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator
 * Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0
 * Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)
 */
$.validator.addMethod(&quot;creditcardtypes&quot;, function(value, element, param) {
	if (/[^0-9\-]+/.test(value)) {
		return false;
	}

	value = value.replace(/\D/g, &quot;&quot;);

	var validTypes = 0x0000;

	if (param.mastercard) {
		validTypes |= 0x0001;
	}
	if (param.visa) {
		validTypes |= 0x0002;
	}
	if (param.amex) {
		validTypes |= 0x0004;
	}
	if (param.dinersclub) {
		validTypes |= 0x0008;
	}
	if (param.enroute) {
		validTypes |= 0x0010;
	}
	if (param.discover) {
		validTypes |= 0x0020;
	}
	if (param.jcb) {
		validTypes |= 0x0040;
	}
	if (param.unknown) {
		validTypes |= 0x0080;
	}
	if (param.all) {
		validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;
	}
	if (validTypes &amp; 0x0001 &amp;&amp; /^(5[12345])/.test(value)) { //mastercard
		return value.length === 16;
	}
	if (validTypes &amp; 0x0002 &amp;&amp; /^(4)/.test(value)) { //visa
		return value.length === 16;
	}
	if (validTypes &amp; 0x0004 &amp;&amp; /^(3[47])/.test(value)) { //amex
		return value.length === 15;
	}
	if (validTypes &amp; 0x0008 &amp;&amp; /^(3(0[012345]|[68]))/.test(value)) { //dinersclub
		return value.length === 14;
	}
	if (validTypes &amp; 0x0010 &amp;&amp; /^(2(014|149))/.test(value)) { //enroute
		return value.length === 15;
	}
	if (validTypes &amp; 0x0020 &amp;&amp; /^(6011)/.test(value)) { //discover
		return value.length === 16;
	}
	if (validTypes &amp; 0x0040 &amp;&amp; /^(3)/.test(value)) { //jcb
		return value.length === 16;
	}
	if (validTypes &amp; 0x0040 &amp;&amp; /^(2131|1800)/.test(value)) { //jcb
		return value.length === 15;
	}
	if (validTypes &amp; 0x0080) { //unknown
		return true;
	}
	return false;
}, &quot;Please enter a valid credit card number.&quot;);

/**
 * Validates currencies with any given symbols by @jameslouiz
 * Symbols can be optional or required. Symbols required by default
 *
 * Usage examples:
 *  currency: [&quot;£&quot;, false] - Use false for soft currency validation
 *  currency: [&quot;$&quot;, false]
 *  currency: [&quot;RM&quot;, false] - also works with text based symbols such as &quot;RM&quot; - Malaysia Ringgit etc
 *
 *  &lt;input class=&quot;currencyInput&quot; name=&quot;currencyInput&quot;&gt;
 *
 * Soft symbol checking
 *  currencyInput: {
 *     currency: [&quot;$&quot;, false]
 *  }
 *
 * Strict symbol checking (default)
 *  currencyInput: {
 *     currency: &quot;$&quot;
 *     //OR
 *     currency: [&quot;$&quot;, true]
 *  }
 *
 * Multiple Symbols
 *  currencyInput: {
 *     currency: &quot;$,£,¢&quot;
 *  }
 */
$.validator.addMethod(&quot;currency&quot;, function(value, element, param) {
    var isParamString = typeof param === &quot;string&quot;,
        symbol = isParamString ? param : param[0],
        soft = isParamString ? true : param[1],
        regex;

    symbol = symbol.replace(/,/g, &quot;&quot;);
    symbol = soft ? symbol + &quot;]&quot; : symbol + &quot;]?&quot;;
    regex = &quot;^[&quot; + symbol + &quot;([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$&quot;;
    regex = new RegExp(regex);
    return this.optional(element) || regex.test(value);

}, &quot;Please specify a valid currency&quot;);

$.validator.addMethod(&quot;dateFA&quot;, function(value, element) {
	return this.optional(element) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test(value);
}, $.validator.messages.date);

/**
 * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.
 *
 * @example $.validator.methods.date(&quot;01/01/1900&quot;)
 * @result true
 *
 * @example $.validator.methods.date(&quot;01/13/1990&quot;)
 * @result false
 *
 * @example $.validator.methods.date(&quot;01.01.1900&quot;)
 * @result false
 *
 * @example &lt;input name=&quot;pippo&quot; class=&quot;{dateITA:true}&quot; /&gt;
 * @desc Declares an optional input element whose value must be a valid date.
 *
 * @name $.validator.methods.dateITA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod(&quot;dateITA&quot;, function(value, element) {
	var check = false,
		re = /^\d{1,2}\/\d{1,2}\/\d{4}$/,
		adata, gg, mm, aaaa, xdata;
	if ( re.test(value)) {
		adata = value.split(&quot;/&quot;);
		gg = parseInt(adata[0], 10);
		mm = parseInt(adata[1], 10);
		aaaa = parseInt(adata[2], 10);
		xdata = new Date(Date.UTC(aaaa, mm - 1, gg, 12, 0, 0, 0));
		if ( ( xdata.getUTCFullYear() === aaaa ) &amp;&amp; ( xdata.getUTCMonth () === mm - 1 ) &amp;&amp; ( xdata.getUTCDate() === gg ) ) {
			check = true;
		} else {
			check = false;
		}
	} else {
		check = false;
	}
	return this.optional(element) || check;
}, $.validator.messages.date);

$.validator.addMethod(&quot;dateNL&quot;, function(value, element) {
	return this.optional(element) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test(value);
}, $.validator.messages.date);

// Older &quot;accept&quot; file extension method. Old docs: http://docs.jquery.com/Plugins/Validation/Methods/accept
$.validator.addMethod(&quot;extension&quot;, function(value, element, param) {
	param = typeof param === &quot;string&quot; ? param.replace(/,/g, &quot;|&quot;) : &quot;png|jpe?g|gif&quot;;
	return this.optional(element) || value.match(new RegExp(&quot;\\.(&quot; + param + &quot;)$&quot;, &quot;i&quot;));
}, $.validator.format(&quot;Please enter a value with a valid extension.&quot;));

/**
 * Dutch giro account numbers (not bank numbers) have max 7 digits
 */
$.validator.addMethod(&quot;giroaccountNL&quot;, function(value, element) {
	return this.optional(element) || /^[0-9]{1,7}$/.test(value);
}, &quot;Please specify a valid giro account number&quot;);

/**
 * IBAN is the international bank account number.
 * It has a country - specific format, that is checked here too
 */
$.validator.addMethod(&quot;iban&quot;, function(value, element) {
	// some quick simple tests to prevent needless work
	if (this.optional(element)) {
		return true;
	}

	// remove spaces and to upper case
	var iban = value.replace(/ /g, &quot;&quot;).toUpperCase(),
		ibancheckdigits = &quot;&quot;,
		leadingZeroes = true,
		cRest = &quot;&quot;,
		cOperator = &quot;&quot;,
		countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;

	// check the country code and find the country specific format
	countrycode = iban.substring(0, 2);
	bbancountrypatterns = {
		&quot;AL&quot;: &quot;\\d{8}[\\dA-Z]{16}&quot;,
		&quot;AD&quot;: &quot;\\d{8}[\\dA-Z]{12}&quot;,
		&quot;AT&quot;: &quot;\\d{16}&quot;,
		&quot;AZ&quot;: &quot;[\\dA-Z]{4}\\d{20}&quot;,
		&quot;BE&quot;: &quot;\\d{12}&quot;,
		&quot;BH&quot;: &quot;[A-Z]{4}[\\dA-Z]{14}&quot;,
		&quot;BA&quot;: &quot;\\d{16}&quot;,
		&quot;BR&quot;: &quot;\\d{23}[A-Z][\\dA-Z]&quot;,
		&quot;BG&quot;: &quot;[A-Z]{4}\\d{6}[\\dA-Z]{8}&quot;,
		&quot;CR&quot;: &quot;\\d{17}&quot;,
		&quot;HR&quot;: &quot;\\d{17}&quot;,
		&quot;CY&quot;: &quot;\\d{8}[\\dA-Z]{16}&quot;,
		&quot;CZ&quot;: &quot;\\d{20}&quot;,
		&quot;DK&quot;: &quot;\\d{14}&quot;,
		&quot;DO&quot;: &quot;[A-Z]{4}\\d{20}&quot;,
		&quot;EE&quot;: &quot;\\d{16}&quot;,
		&quot;FO&quot;: &quot;\\d{14}&quot;,
		&quot;FI&quot;: &quot;\\d{14}&quot;,
		&quot;FR&quot;: &quot;\\d{10}[\\dA-Z]{11}\\d{2}&quot;,
		&quot;GE&quot;: &quot;[\\dA-Z]{2}\\d{16}&quot;,
		&quot;DE&quot;: &quot;\\d{18}&quot;,
		&quot;GI&quot;: &quot;[A-Z]{4}[\\dA-Z]{15}&quot;,
		&quot;GR&quot;: &quot;\\d{7}[\\dA-Z]{16}&quot;,
		&quot;GL&quot;: &quot;\\d{14}&quot;,
		&quot;GT&quot;: &quot;[\\dA-Z]{4}[\\dA-Z]{20}&quot;,
		&quot;HU&quot;: &quot;\\d{24}&quot;,
		&quot;IS&quot;: &quot;\\d{22}&quot;,
		&quot;IE&quot;: &quot;[\\dA-Z]{4}\\d{14}&quot;,
		&quot;IL&quot;: &quot;\\d{19}&quot;,
		&quot;IT&quot;: &quot;[A-Z]\\d{10}[\\dA-Z]{12}&quot;,
		&quot;KZ&quot;: &quot;\\d{3}[\\dA-Z]{13}&quot;,
		&quot;KW&quot;: &quot;[A-Z]{4}[\\dA-Z]{22}&quot;,
		&quot;LV&quot;: &quot;[A-Z]{4}[\\dA-Z]{13}&quot;,
		&quot;LB&quot;: &quot;\\d{4}[\\dA-Z]{20}&quot;,
		&quot;LI&quot;: &quot;\\d{5}[\\dA-Z]{12}&quot;,
		&quot;LT&quot;: &quot;\\d{16}&quot;,
		&quot;LU&quot;: &quot;\\d{3}[\\dA-Z]{13}&quot;,
		&quot;MK&quot;: &quot;\\d{3}[\\dA-Z]{10}\\d{2}&quot;,
		&quot;MT&quot;: &quot;[A-Z]{4}\\d{5}[\\dA-Z]{18}&quot;,
		&quot;MR&quot;: &quot;\\d{23}&quot;,
		&quot;MU&quot;: &quot;[A-Z]{4}\\d{19}[A-Z]{3}&quot;,
		&quot;MC&quot;: &quot;\\d{10}[\\dA-Z]{11}\\d{2}&quot;,
		&quot;MD&quot;: &quot;[\\dA-Z]{2}\\d{18}&quot;,
		&quot;ME&quot;: &quot;\\d{18}&quot;,
		&quot;NL&quot;: &quot;[A-Z]{4}\\d{10}&quot;,
		&quot;NO&quot;: &quot;\\d{11}&quot;,
		&quot;PK&quot;: &quot;[\\dA-Z]{4}\\d{16}&quot;,
		&quot;PS&quot;: &quot;[\\dA-Z]{4}\\d{21}&quot;,
		&quot;PL&quot;: &quot;\\d{24}&quot;,
		&quot;PT&quot;: &quot;\\d{21}&quot;,
		&quot;RO&quot;: &quot;[A-Z]{4}[\\dA-Z]{16}&quot;,
		&quot;SM&quot;: &quot;[A-Z]\\d{10}[\\dA-Z]{12}&quot;,
		&quot;SA&quot;: &quot;\\d{2}[\\dA-Z]{18}&quot;,
		&quot;RS&quot;: &quot;\\d{18}&quot;,
		&quot;SK&quot;: &quot;\\d{20}&quot;,
		&quot;SI&quot;: &quot;\\d{15}&quot;,
		&quot;ES&quot;: &quot;\\d{20}&quot;,
		&quot;SE&quot;: &quot;\\d{20}&quot;,
		&quot;CH&quot;: &quot;\\d{5}[\\dA-Z]{12}&quot;,
		&quot;TN&quot;: &quot;\\d{20}&quot;,
		&quot;TR&quot;: &quot;\\d{5}[\\dA-Z]{17}&quot;,
		&quot;AE&quot;: &quot;\\d{3}\\d{16}&quot;,
		&quot;GB&quot;: &quot;[A-Z]{4}\\d{14}&quot;,
		&quot;VG&quot;: &quot;[\\dA-Z]{4}\\d{16}&quot;
	};

	bbanpattern = bbancountrypatterns[countrycode];
	// As new countries will start using IBAN in the
	// future, we only check if the countrycode is known.
	// This prevents false negatives, while almost all
	// false positives introduced by this, will be caught
	// by the checksum validation below anyway.
	// Strict checking should return FALSE for unknown
	// countries.
	if (typeof bbanpattern !== &quot;undefined&quot;) {
		ibanregexp = new RegExp(&quot;^[A-Z]{2}\\d{2}&quot; + bbanpattern + &quot;$&quot;, &quot;&quot;);
		if (!(ibanregexp.test(iban))) {
			return false; // invalid country specific format
		}
	}

	// now check the checksum, first convert to digits
	ibancheck = iban.substring(4, iban.length) + iban.substring(0, 4);
	for (i = 0; i &lt; ibancheck.length; i++) {
		charAt = ibancheck.charAt(i);
		if (charAt !== &quot;0&quot;) {
			leadingZeroes = false;
		}
		if (!leadingZeroes) {
			ibancheckdigits += &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.indexOf(charAt);
		}
	}

	// calculate the result of: ibancheckdigits % 97
	for (p = 0; p &lt; ibancheckdigits.length; p++) {
		cChar = ibancheckdigits.charAt(p);
		cOperator = &quot;&quot; + cRest + &quot;&quot; + cChar;
		cRest = cOperator % 97;
	}
	return cRest === 1;
}, &quot;Please specify a valid IBAN&quot;);

$.validator.addMethod(&quot;integer&quot;, function(value, element) {
	return this.optional(element) || /^-?\d+$/.test(value);
}, &quot;A positive or negative non-decimal number please&quot;);

$.validator.addMethod(&quot;ipv4&quot;, function(value, element) {
	return this.optional(element) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test(value);
}, &quot;Please enter a valid IP v4 address.&quot;);

$.validator.addMethod(&quot;ipv6&quot;, function(value, element) {
	return this.optional(element) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(value);
}, &quot;Please enter a valid IP v6 address.&quot;);

$.validator.addMethod(&quot;lettersonly&quot;, function(value, element) {
	return this.optional(element) || /^[a-z]+$/i.test(value);
}, &quot;Letters only please&quot;);

$.validator.addMethod(&quot;letterswithbasicpunc&quot;, function(value, element) {
	return this.optional(element) || /^[a-z\-.,()&#x27;&quot;\s]+$/i.test(value);
}, &quot;Letters or punctuation only please&quot;);

$.validator.addMethod(&quot;mobileNL&quot;, function(value, element) {
	return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
}, &quot;Please specify a valid mobile number&quot;);

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to &#x27;+44&lt;space&gt;&#x27; if $1 is &#x27;44&#x27;, otherwise set $prefix to &#x27;0&#x27;
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod(&quot;mobileUK&quot;, function(phone_number, element) {
	phone_number = phone_number.replace(/\(|\)|\s+|-/g, &quot;&quot;);
	return this.optional(element) || phone_number.length &gt; 9 &amp;&amp;
		phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/);
}, &quot;Please specify a valid mobile number&quot;);

/*
 * The número de identidad de extranjero ( NIE )is a code used to identify the non-nationals in Spain
 */
$.validator.addMethod( &quot;nieES&quot;, function( value ) {
	&quot;use strict&quot;;

	value = value.toUpperCase();

	// Basic format test
	if ( !value.match( &quot;((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)&quot; ) ) {
		return false;
	}

	// Test NIE
	//T
	if ( /^[T]{1}/.test( value ) ) {
		return ( value[ 8 ] === /^[T]{1}[A-Z0-9]{8}$/.test( value ) );
	}

	//XYZ
	if ( /^[XYZ]{1}/.test( value ) ) {
		return (
			value[ 8 ] === &quot;TRWAGMYFPDXBNJZSQVHLCKE&quot;.charAt(
				value.replace( &quot;X&quot;, &quot;0&quot; )
					.replace( &quot;Y&quot;, &quot;1&quot; )
					.replace( &quot;Z&quot;, &quot;2&quot; )
					.substring( 0, 8 ) % 23
			)
		);
	}

	return false;

}, &quot;Please specify a valid NIE number.&quot; );

/*
 * The Número de Identificación Fiscal ( NIF ) is the way tax identification used in Spain for individuals
 */
$.validator.addMethod( &quot;nifES&quot;, function( value ) {
	&quot;use strict&quot;;

	value = value.toUpperCase();

	// Basic format test
	if ( !value.match(&quot;((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)&quot;) ) {
		return false;
	}

	// Test NIF
	if ( /^[0-9]{8}[A-Z]{1}$/.test( value ) ) {
		return ( &quot;TRWAGMYFPDXBNJZSQVHLCKE&quot;.charAt( value.substring( 8, 0 ) % 23 ) === value.charAt( 8 ) );
	}
	// Test specials NIF (starts with K, L or M)
	if ( /^[KLM]{1}/.test( value ) ) {
		return ( value[ 8 ] === String.fromCharCode( 64 ) );
	}

	return false;

}, &quot;Please specify a valid NIF number.&quot; );

jQuery.validator.addMethod( &quot;notEqualTo&quot;, function( value, element, param ) {
	return this.optional(element) || !$.validator.methods.equalTo.call( this, value, element, param );
}, &quot;Please enter a different value, values must not be the same.&quot; );

$.validator.addMethod(&quot;nowhitespace&quot;, function(value, element) {
	return this.optional(element) || /^\S+$/i.test(value);
}, &quot;No white space please&quot;);

/**
* Return true if the field value matches the given format RegExp
*
* @example $.validator.methods.pattern(&quot;AR1004&quot;,element,/^AR\d{4}$/)
* @result true
*
* @example $.validator.methods.pattern(&quot;BR1004&quot;,element,/^AR\d{4}$/)
* @result false
*
* @name $.validator.methods.pattern
* @type Boolean
* @cat Plugins/Validate/Methods
*/
$.validator.addMethod(&quot;pattern&quot;, function(value, element, param) {
	if (this.optional(element)) {
		return true;
	}
	if (typeof param === &quot;string&quot;) {
		param = new RegExp(&quot;^(?:&quot; + param + &quot;)$&quot;);
	}
	return param.test(value);
}, &quot;Invalid format.&quot;);

/**
 * Dutch phone numbers have 10 digits (or 11 and start with +31).
 */
$.validator.addMethod(&quot;phoneNL&quot;, function(value, element) {
	return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
}, &quot;Please specify a valid phone number.&quot;);

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to &#x27;+44&lt;space&gt;&#x27; if $1 is &#x27;44&#x27;, otherwise set $prefix to &#x27;0&#x27;
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod(&quot;phoneUK&quot;, function(phone_number, element) {
	phone_number = phone_number.replace(/\(|\)|\s+|-/g, &quot;&quot;);
	return this.optional(element) || phone_number.length &gt; 9 &amp;&amp;
		phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/);
}, &quot;Please specify a valid phone number&quot;);

/**
 * matches US phone number format
 *
 * where the area code may not start with 1 and the prefix may not start with 1
 * allows &#x27;-&#x27; or &#x27; &#x27; as a separator and allows parens around area code
 * some people may want to put a &#x27;1&#x27; in front of their number
 *
 * 1(212)-999-2345 or
 * 212 999 2344 or
 * 212-999-0983
 *
 * but not
 * 111-123-5434
 * and not
 * 212 123 4567
 */
$.validator.addMethod(&quot;phoneUS&quot;, function(phone_number, element) {
	phone_number = phone_number.replace(/\s+/g, &quot;&quot;);
	return this.optional(element) || phone_number.length &gt; 9 &amp;&amp;
		phone_number.match(/^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/);
}, &quot;Please specify a valid phone number&quot;);

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to &#x27;+44&lt;space&gt;&#x27; if $1 is &#x27;44&#x27;, otherwise set $prefix to &#x27;0&#x27;
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
//Matches UK landline + mobile, accepting only 01-3 for landline or 07 for mobile to exclude many premium numbers
$.validator.addMethod(&quot;phonesUK&quot;, function(phone_number, element) {
	phone_number = phone_number.replace(/\(|\)|\s+|-/g, &quot;&quot;);
	return this.optional(element) || phone_number.length &gt; 9 &amp;&amp;
		phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/);
}, &quot;Please specify a valid uk phone number&quot;);

/**
 * Matches a valid Canadian Postal Code
 *
 * @example jQuery.validator.methods.postalCodeCA( &quot;H0H 0H0&quot;, element )
 * @result true
 *
 * @example jQuery.validator.methods.postalCodeCA( &quot;H0H0H0&quot;, element )
 * @result false
 *
 * @name jQuery.validator.methods.postalCodeCA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( &quot;postalCodeCA&quot;, function( value, element ) {
	return this.optional( element ) || /^[ABCEGHJKLMNPRSTVXY]\d[A-Z] \d[A-Z]\d$/.test( value );
}, &quot;Please specify a valid postal code&quot; );

/*
* Valida CEPs do brasileiros:
*
* Formatos aceitos:
* 99999-999
* 99.999-999
* 99999999
*/
$.validator.addMethod(&quot;postalcodeBR&quot;, function(cep_value, element) {
	return this.optional(element) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test( cep_value );
}, &quot;Informe um CEP válido.&quot;);

/* Matches Italian postcode (CAP) */
$.validator.addMethod(&quot;postalcodeIT&quot;, function(value, element) {
	return this.optional(element) || /^\d{5}$/.test(value);
}, &quot;Please specify a valid postal code&quot;);

$.validator.addMethod(&quot;postalcodeNL&quot;, function(value, element) {
	return this.optional(element) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test(value);
}, &quot;Please specify a valid postal code&quot;);

// Matches UK postcode. Does not match to UK Channel Islands that have their own postcodes (non standard UK)
$.validator.addMethod(&quot;postcodeUK&quot;, function(value, element) {
	return this.optional(element) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test(value);
}, &quot;Please specify a valid UK postcode&quot;);

/*
 * Lets you say &quot;at least X inputs that match selector Y must be filled.&quot;
 *
 * The end result is that neither of these inputs:
 *
 *	&lt;input class=&quot;productinfo&quot; name=&quot;partnumber&quot;&gt;
 *	&lt;input class=&quot;productinfo&quot; name=&quot;description&quot;&gt;
 *
 *	...will validate unless at least one of them is filled.
 *
 * partnumber:	{require_from_group: [1,&quot;.productinfo&quot;]},
 * description: {require_from_group: [1,&quot;.productinfo&quot;]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 */
$.validator.addMethod(&quot;require_from_group&quot;, function(value, element, options) {
	var $fields = $(options[1], element.form),
		$fieldsFirst = $fields.eq(0),
		validator = $fieldsFirst.data(&quot;valid_req_grp&quot;) ? $fieldsFirst.data(&quot;valid_req_grp&quot;) : $.extend({}, this),
		isValid = $fields.filter(function() {
			return validator.elementValue(this);
		}).length &gt;= options[0];

	// Store the cloned validator for future validation
	$fieldsFirst.data(&quot;valid_req_grp&quot;, validator);

	// If element isn&#x27;t being validated, run each require_from_group field&#x27;s validation rules
	if (!$(element).data(&quot;being_validated&quot;)) {
		$fields.data(&quot;being_validated&quot;, true);
		$fields.each(function() {
			validator.element(this);
		});
		$fields.data(&quot;being_validated&quot;, false);
	}
	return isValid;
}, $.validator.format(&quot;Please fill at least {0} of these fields.&quot;));

/*
 * Lets you say &quot;either at least X inputs that match selector Y must be filled,
 * OR they must all be skipped (left blank).&quot;
 *
 * The end result, is that none of these inputs:
 *
 *	&lt;input class=&quot;productinfo&quot; name=&quot;partnumber&quot;&gt;
 *	&lt;input class=&quot;productinfo&quot; name=&quot;description&quot;&gt;
 *	&lt;input class=&quot;productinfo&quot; name=&quot;color&quot;&gt;
 *
 *	...will validate unless either at least two of them are filled,
 *	OR none of them are.
 *
 * partnumber:	{skip_or_fill_minimum: [2,&quot;.productinfo&quot;]},
 * description: {skip_or_fill_minimum: [2,&quot;.productinfo&quot;]},
 * color:		{skip_or_fill_minimum: [2,&quot;.productinfo&quot;]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 *
 */
$.validator.addMethod(&quot;skip_or_fill_minimum&quot;, function(value, element, options) {
	var $fields = $(options[1], element.form),
		$fieldsFirst = $fields.eq(0),
		validator = $fieldsFirst.data(&quot;valid_skip&quot;) ? $fieldsFirst.data(&quot;valid_skip&quot;) : $.extend({}, this),
		numberFilled = $fields.filter(function() {
			return validator.elementValue(this);
		}).length,
		isValid = numberFilled === 0 || numberFilled &gt;= options[0];

	// Store the cloned validator for future validation
	$fieldsFirst.data(&quot;valid_skip&quot;, validator);

	// If element isn&#x27;t being validated, run each skip_or_fill_minimum field&#x27;s validation rules
	if (!$(element).data(&quot;being_validated&quot;)) {
		$fields.data(&quot;being_validated&quot;, true);
		$fields.each(function() {
			validator.element(this);
		});
		$fields.data(&quot;being_validated&quot;, false);
	}
	return isValid;
}, $.validator.format(&quot;Please either skip these fields or fill at least {0} of them.&quot;));

/* Validates US States and/or Territories by @jdforsythe
 * Can be case insensitive or require capitalization - default is case insensitive
 * Can include US Territories or not - default does not
 * Can include US Military postal abbreviations (AA, AE, AP) - default does not
 *
 * Note: &quot;States&quot; always includes DC (District of Colombia)
 *
 * Usage examples:
 *
 *  This is the default - case insensitive, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false,
 *     includeTerritories: false,
 *     includeMilitary: false
 *  }
 *
 *  Only allow capital letters, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false
 *  }
 *
 *  Case insensitive, include territories but not military zones
 *  stateInput: {
 *     includeTerritories: true
 *  }
 *
 *  Only allow capital letters, include territories and military zones
 *  stateInput: {
 *     caseSensitive: true,
 *     includeTerritories: true,
 *     includeMilitary: true
 *  }
 *
 *
 *
 */

$.validator.addMethod(&quot;stateUS&quot;, function(value, element, options) {
	var isDefault = typeof options === &quot;undefined&quot;,
		caseSensitive = ( isDefault || typeof options.caseSensitive === &quot;undefined&quot; ) ? false : options.caseSensitive,
		includeTerritories = ( isDefault || typeof options.includeTerritories === &quot;undefined&quot; ) ? false : options.includeTerritories,
		includeMilitary = ( isDefault || typeof options.includeMilitary === &quot;undefined&quot; ) ? false : options.includeMilitary,
		regex;

	if (!includeTerritories &amp;&amp; !includeMilitary) {
		regex = &quot;^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$&quot;;
	} else if (includeTerritories &amp;&amp; includeMilitary) {
		regex = &quot;^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$&quot;;
	} else if (includeTerritories) {
		regex = &quot;^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$&quot;;
	} else {
		regex = &quot;^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$&quot;;
	}

	regex = caseSensitive ? new RegExp(regex) : new RegExp(regex, &quot;i&quot;);
	return this.optional(element) || regex.test(value);
},
&quot;Please specify a valid state&quot;);

// TODO check if value starts with &lt;, otherwise don&#x27;t try stripping anything
$.validator.addMethod(&quot;strippedminlength&quot;, function(value, element, param) {
	return $(value).text().length &gt;= param;
}, $.validator.format(&quot;Please enter at least {0} characters&quot;));

$.validator.addMethod(&quot;time&quot;, function(value, element) {
	return this.optional(element) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test(value);
}, &quot;Please enter a valid time, between 00:00 and 23:59&quot;);

$.validator.addMethod(&quot;time12h&quot;, function(value, element) {
	return this.optional(element) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test(value);
}, &quot;Please enter a valid time in 12-hour am/pm format&quot;);

// same as url, but TLD is optional
$.validator.addMethod(&quot;url2&quot;, function(value, element) {
	return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
}, $.validator.messages.url);

/**
 * Return true, if the value is a valid vehicle identification number (VIN).
 *
 * Works with all kind of text inputs.
 *
 * @example &lt;input type=&quot;text&quot; size=&quot;20&quot; name=&quot;VehicleID&quot; class=&quot;{required:true,vinUS:true}&quot; /&gt;
 * @desc Declares a required input element whose value must be a valid vehicle identification number.
 *
 * @name $.validator.methods.vinUS
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod(&quot;vinUS&quot;, function(v) {
	if (v.length !== 17) {
		return false;
	}

	var LL = [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;P&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; ],
		VL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ],
		FL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ],
		rs = 0,
		i, n, d, f, cd, cdv;

	for (i = 0; i &lt; 17; i++) {
		f = FL[i];
		d = v.slice(i, i + 1);
		if (i === 8) {
			cdv = d;
		}
		if (!isNaN(d)) {
			d *= f;
		} else {
			for (n = 0; n &lt; LL.length; n++) {
				if (d.toUpperCase() === LL[n]) {
					d = VL[n];
					d *= f;
					if (isNaN(cdv) &amp;&amp; n === 8) {
						cdv = LL[n];
					}
					break;
				}
			}
		}
		rs += d;
	}
	cd = rs % 11;
	if (cd === 10) {
		cd = &quot;X&quot;;
	}
	if (cd === cdv) {
		return true;
	}
	return false;
}, &quot;The specified vehicle identification number (VIN) is invalid.&quot;);

$.validator.addMethod(&quot;zipcodeUS&quot;, function(value, element) {
	return this.optional(element) || /^\d{5}(-\d{4})?$/.test(value);
}, &quot;The specified US ZIP Code is invalid&quot;);

$.validator.addMethod(&quot;ziprange&quot;, function(value, element) {
	return this.optional(element) || /^90[2-5]\d\{2\}-\d{4}$/.test(value);
}, &quot;Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx&quot;);

}));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
